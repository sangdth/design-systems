---
description: Senior React expert specializing in React 18+, modern patterns, performance optimization, and scalable production architectures for exceptional user experiences.
alwaysApply: false
---

# React Developer Rule

## Core Tools

- **Vite**: Modern build tool with fast HMR
- **Jest/Cypress**: Unit and E2E testing
- **Storybook**: Component development
- **React DevTools**: Performance profiling
- **TypeScript**: Type safety

## Workflow

### 1. Architecture Planning

Design scalable React architecture:

- Define component structure (atomic design, container/presentational)
- Choose state management (Redux Toolkit, Zustand, Jotai, Context API)
- Plan routing strategy and data fetching approach
- Set performance goals (> 95 score, < 2s load time)
- Define testing strategy (> 90% coverage)
- Configure build tools and deployment pipeline

### 2. Implementation

Build high-performance React applications:

- **Components**: Create reusable, composable components with TypeScript
- **State**: Implement state management (local, global, server, URL)
- **Performance**: React.memo, useMemo, useCallback, code splitting
- **Testing**: Unit tests (Jest), integration tests, E2E (Cypress),
  accessibility tests
- **Error Handling**: Error boundaries, suspense boundaries
- **Accessibility**: ARIA attributes, keyboard navigation, semantic HTML
- **Optimization**: Bundle analysis, lazy loading, virtual scrolling

**Best Practices:**

- Use TypeScript strict mode
- Follow React 18+ patterns (concurrent features, transitions)
- Write tests alongside components
- Optimize renders with memo/useMemo/useCallback
- Implement proper error boundaries
- Ensure accessibility compliance

### 3. React Excellence

Ensure production-ready applications:

- **Performance**: Load time < 2s, TTI < 3s, FCP < 1s, Core Web Vitals
  passed
- **Testing**: > 90% coverage, unit/integration/E2E tests passing
- **Accessibility**: WCAG compliant, keyboard navigation, screen reader support
- **Bundle**: Optimized size, code splitting, lazy loading
- **SEO**: Meta tags, SSR/SSG when needed, structured data

## Key Considerations

**Advanced React Patterns:**

- Compound components, render props, HOCs
- Custom hooks design and reusability
- Context optimization (split contexts, memoization)
- Ref forwarding, portals, lazy loading

**State Management:**

- Redux Toolkit for complex state
- Zustand/Jotai for simpler needs
- Context API for theme/auth
- React Query/TanStack for server state
- URL state for shareable UI state

**Performance Optimization:**

- React.memo for expensive components
- useMemo for expensive calculations
- useCallback for function props
- Code splitting with React.lazy and Suspense
- Virtual scrolling for long lists
- Concurrent features (useTransition, useDeferredValue)

**Hooks Best Practices:**

- useState for component state
- useEffect with proper dependencies
- useContext sparingly (avoid prop drilling)
- useReducer for complex state logic
- Custom hooks for reusable logic
- useRef for DOM access and values

**React 18+ Features:**

- Server components (Next.js 13+, Remix)
- Streaming SSR and progressive hydration
- useTransition for non-urgent updates
- useDeferredValue for deferred values
- Suspense for data fetching
- Automatic batching
- Error boundaries for error handling

**Testing Strategy:**

- React Testing Library for unit/integration tests
- Jest for test runner and mocking
- Cypress for E2E tests
- Component testing in isolation
- Hook testing with renderHook
- Accessibility testing (jest-axe)
- Performance testing (lighthouse CI)

**React Ecosystem:**

- React Query/TanStack for data fetching
- React Hook Form for forms
- Framer Motion/React Spring for animations
- Tailwind CSS/Styled Components/Material-UI for styling
- Next.js/Remix for SSR frameworks

**Component Patterns:**

- Atomic design (atoms, molecules, organisms)
- Container/presentational separation
- Controlled vs uncontrolled components
- Composition over inheritance
- Children patterns and slots

**SSR/SSG Frameworks:**

- Next.js: App Router, Server Components, Streaming SSR
- Remix: Nested routing, progressive enhancement
- Server components for zero-JS interactivity
- SEO optimization with meta tags
- Data fetching strategies (SSG, SSR, ISR)

**Migration Strategies:**

- Class to function components gradually
- Legacy lifecycle methods to hooks
- State management migration (Redux → Zustand)
- Build tool migration (CRA → Vite)
- TypeScript adoption incrementally

**Code Quality:**

- TypeScript strict mode enabled
- ESLint + Prettier configured
- Husky pre-commit hooks
- Conventional commits
- Code reviews and documentation

Always prioritize performance, maintainability, and user experience while
building React applications that scale effectively and deliver exceptional
results.
